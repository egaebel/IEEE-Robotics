diff --git a/ROBOT_2013/Information/Thumbs.db b/ROBOT_2013/Information/Thumbs.db
new file mode 100644
index 0000000..38d325e
Binary files /dev/null and b/ROBOT_2013/Information/Thumbs.db differ
diff --git a/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/BackEndColorSensor.cpp b/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/BackEndColorSensor.cpp
deleted file mode 100644
index 14bb824..0000000
--- a/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/BackEndColorSensor.cpp	
+++ /dev/null
@@ -1,145 +0,0 @@
-#include "BackEndColorSensor.h"
-/*Pin Constants */
-int S0 = 22;//pinB
-int S1 = 24;//pinA //26 on other
-int S2 = 26;//pinE //30 on other
-int S3 = 28;//pinF //34 on other
-int taosOutPin = 30;//pinC //38 on other
-int LED = 32;//pinD //42 on other
-
-bool LEDstate = 1; //LED is turned on
-
-
-//------------------------------TESTING ONLY ------------------------------------------------
-/**
- * FOR TESTING SERIAL OUTPUT READ PULSE
- */
- /*
-void loop()	{
-	//delay(150); //Pauses program for 100ms
-	detectColor(taosOutPin); //read pulse readings for each color W,R,G,B
-	delay(100); //100ms delay between pulse reads
-}
-*/
-/**
- * FOR TESTING SERIAL OUTPUT READ PULSE
- */
- /*
-void setup() {
-	TCS3200setup();
-	Serial.begin(115200); //Sets the data transfer rate at 115.2 Kbps
-	Serial.print("\n\n\nready\n\n\n\n\n\n");
-
-	Serial.print("White: ");
-	Serial.print(colorRead(0));
-
-	Serial.print("\n\nBlue: ");
-	Serial.print(colorRead(1));
-
-	Serial.print("\n\nRed: ");
-	Serial.print(colorRead(2));
-
-	Serial.print("\n\nGreen: ");
-	Serial.print(colorRead(3));
-
-	Serial.print("\n\n\n\n");
-}
-*/
-//--------------------------------END OF TESTING ONLY --------------------------------------------
-
-
-/**
- * calls the setUp method for the TC3200 sensor
- */
-BackEndColorSensor::BackEndColorSensor()    {
-    TCS3200setup();
-}
-
-/**
- * Public method called on from the ColorSensor class
- * @param color : the desried color to pulse read
-                    0 = white
-                    1 = blue
-                    2 = red
-                    3 = green
- *
- * @returns the pulse of the desired color
- */
-int BackEndColorSensor::colorRead(int color)    {
-
-    //set the S2 and S3 pins to select the color to be sensed
-    if(color == 0){//white
-        digitalWrite(S3, LOW); //S3
-        digitalWrite(S2, HIGH); //S2
-        // Serial.print(" w");
-    }
-
-    else if(color == 1){//red
-        digitalWrite(S3, LOW); //S3
-        digitalWrite(S2, LOW); //S2
-        // Serial.print(" r");
-    }
-
-    else if(color == 2){//blue
-        digitalWrite(S3, HIGH); //S3
-        digitalWrite(S2, LOW); //S2
-        // Serial.print(" b");
-    }
-
-    else if(color == 3){//green
-        digitalWrite(S3, HIGH); //S3
-        digitalWrite(S2, HIGH); //S2
-        // Serial.print(" g");
-    }
-
-    int readPulse; //where the pulse reading from sensor will go
-
-    
-
-    delay(100); //Delay for 100ms for before reading
-
-    // now take a measurement from the sensor, timing a low pulse on the sensor's "out" pin
-    readPulse = int(pulseIn(taosOutPin, LOW, 80000));
-
-    //if the pulseIn times out, it returns 0 and that throws off numbers, so set any to 1.
-    if(readPulse < 1){
-        readPulse = 1;
-    }
-
-    // return the pulse value back to whatever called for it...
-    return readPulse;
-}
-
-/**
-* Setup for the Sensor
-*/
-void BackEndColorSensor::TCS3200setup()   {
-    //initialize pins
-    pinMode(LED,OUTPUT); //LED pinD
-
-    //color mode selection
-    pinMode(S2,OUTPUT); //S2 pinE
-    pinMode(S3,OUTPUT); //s3 pinF
-
-    //color response pin (only actual input from taos)
-    pinMode(taosOutPin, INPUT); //taosOutPin pinC
-
-    //communication freq (sensitivity) selection
-    pinMode(S0,OUTPUT); //S0 pinB
-    pinMode(S1,OUTPUT); //S1 pinA
-
-    //this will put in 1:1, highest sensitivity
-    digitalWrite(S0, HIGH); //S0
-    digitalWrite(S1, HIGH); //S1
-    
-    digitalWrite(LED, HIGH);
-    
-    return;
-}
-
-/**
- * Returns the pulse value for the desired color
- *
- */
-
-
diff --git a/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/BackEndColorSensor.h b/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/BackEndColorSensor.h
deleted file mode 100644
index 0513081..0000000
--- a/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/BackEndColorSensor.h	
+++ /dev/null
@@ -1,13 +0,0 @@
-#ifndef BACKENDCOLORSENSOR_H
-#define BACKENDCOLORSENSOR_H
-#include <Arduino.h>
-class BackEndColorSensor
-{
-    public:
-        BackEndColorSensor(); //Nescessary color sensor setup called in constructor
-        int colorRead(int color);
-    private:
-        void TCS3200setup();
-};
-
-#endif // BACKENDCOLORSENSOR_H
diff --git a/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/colorPulseValues.txt b/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/colorPulseValues.txt
deleted file mode 100644
index fa0b758..0000000
--- a/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/colorPulseValues.txt	
+++ /dev/null
@@ -1,151 +0,0 @@
-
-White2380
- Blue6858
- Red:8906
- Green:8071
-
-
-
-
-White708
- Blue1999
- Red:2912
- Green:3496
-
-
-
-
-White512
- Blue1289
- Red:1481
- Green:1356
-
-
-
-
-White267
- Blue648
- Red:745
- Green:816
-
-
-
-
-White386
- Blue952
- Red:1005
- Green:1011
-
-
-
-
-White132
- Blue363
- Red:321
- Green:398
-
-
-
-
-
- White--------------------------------------------------------------------------------------------------------
-
-
-White8
- Blue25
- Red:29
- Green:43
-
-
-
-
-White7
- Blue25
- Red:28
- Green:28
-
-
-
-
-White4
- Blue19
- Red:18
- Green:20
-
-
-
-
-White6
- Blue20
- Red:19
- Green:22
-
-
-
-
-White6
- Blue19
- Red:18
- Green:20
-
-
-
-
-
- --------------------------------------------------------------- BLUE
-
-
- White157
- Blue620
- Red:221
- Green:377
-
-
-
-
-White49
- Blue264
- Red:74
- Green:150
-
-
-
-
-White46
- Blue310
- Red:67
- Green:148
-
-
-
-
-White45
- Blue348
- Red:74
- Green:154
-
-
-
-
-White52
- Blue410
- Red:81
- Green:162
-
-
-
-
-White41
- Blue283
- Red:64
- Green:142
-
-
-
-
-White: 41
- Blue229
- Red:69
- Green:159
-
-
diff --git a/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/colorSensor.cpp b/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/colorSensor.cpp
deleted file mode 100644
index f72d067..0000000
--- a/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/colorSensor.cpp	
+++ /dev/null
@@ -1,127 +0,0 @@
-#include "ColorSensor.h"
-/*Pin Constants */
-
-
-
-
-
-/**
-* calls the setUp method for the TC3200 sensor
-*/
-ColorSensor::ColorSensor() {
-    TCS3200setup();
-}
-
-/**
-* Public method called on from the ColorSensor class
-* @param color : the desried color to pulse read
-0 = white
-1 = blue
-2 = red
-3 = green
-*
-* @returns the pulse of the desired color
-*/
-int ColorSensor::colorRead(int color) {
-
-    //set the S2 and S3 pins to select the color to be sensed
-    if(color == 0){//white
-        digitalWrite(S3, LOW); //S3
-        digitalWrite(S2, HIGH); //S2
-        // Serial.print(" w");
-    }
-
-    else if(color == 1){//red
-        digitalWrite(S3, LOW); //S3
-        digitalWrite(S2, LOW); //S2
-        // Serial.print(" r");
-    }
-
-    else if(color == 2){//blue
-        digitalWrite(S3, HIGH); //S3
-        digitalWrite(S2, LOW); //S2
-        // Serial.print(" b");
-    }
-
-    else if(color == 3){//green
-        digitalWrite(S3, HIGH); //S3
-        digitalWrite(S2, HIGH); //S2
-        // Serial.print(" g");
-    }
-
-    int readPulse; //where the pulse reading from sensor will go
-
-    
-
-    delay(100); //Delay for 100ms for before reading
-
-    // now take a measurement from the sensor, timing a low pulse on the sensor's "out" pin
-    readPulse = int(pulseIn(taosOutPin, LOW, 80000));
-
-    //if the pulseIn times out, it returns 0 and that throws off numbers, so set any to 1.
-    if(readPulse < 1){
-        readPulse = 1;
-    }
-
-    // return the pulse value back to whatever called for it...
-    return readPulse;
-}
-
-/**
-* Setup for the Sensor
-*/
-void ColorSensor::TCS3200setup() {
-    //initialize pins
-    pinMode(LED,OUTPUT); //LED pinD
-
-    //color mode selection
-    pinMode(S2,OUTPUT); //S2 pinE
-    pinMode(S3,OUTPUT); //s3 pinF
-
-    //color response pin (only actual input from taos)
-    pinMode(taosOutPin, INPUT); //taosOutPin pinC
-
-    //communication freq (sensitivity) selection
-    pinMode(S0,OUTPUT); //S0 pinB
-    pinMode(S1,OUTPUT); //S1 pinA
-
-    //this will put in 1:1, highest sensitivity
-    digitalWrite(S0, HIGH); //S0
-    digitalWrite(S1, HIGH); //S1
-    
-    digitalWrite(LED, HIGH);
-    
-    return;
-}
-
-/**
-* Return values:
-* 0 = White
-* 1 = Black
-* 2 = Blue
-* 3 = Un-sure
-*/
-int ColorSensor::getColor() {
-    int whiteVal = colorRead(0);
-    int redVal = colorRead(2);
-    int greenVal = colorRead(3);
-    int blueVal = colorRead(1);
-
-    if(blueVal > redVal + greenVal) {
-        return 2;
-    }
-
-    else if(blueVal + greenVal + redVal < 200) {
-        return 0;
-    }
-
-    else if(blueVal + greenVal + redVal > 2000) {
-        return 1;
-    }
-
-    else { //Un-sure of color
-        return 3;
-    }
-}
-
-
diff --git a/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/colorSensor.h b/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/colorSensor.h
deleted file mode 100644
index 4633ff0..0000000
--- a/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/colorSensor.h	
+++ /dev/null
@@ -1,22 +0,0 @@
-#ifndef COLORSENSOR_H
-#define COLORSENSOR_H
-#include <Arduino.h>
-class ColorSensor
-{
-    public:
-        ColorSensor(); //Nescessary color sensor setup called in constructor
-        int colorRead(int color);
-        int getColor();
-    private:
-        void TCS3200setup();
-        int S0 = 22;//pinB
-                int S1 = 24;//pinA //26 on other
-                int S2 = 26;//pinE //30 on other
-                int S3 = 28;//pinF //34 on other
-                int taosOutPin = 30;//pinC //38 on other
-                int LED = 32;//pinD //42 on other
-                bool LEDstate = 1; //LED is turned on
-        
-};
-
-#endif // COLORSENSOR_H
diff --git a/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/colorSsnrorPulseReader.ino b/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/colorSsnrorPulseReader.ino
deleted file mode 100644
index b9c1198..0000000
--- a/ROBOT_2013/Libraries/Color Sensor/sketchbook/colorSsnrorPulseReader/colorSsnrorPulseReader.ino	
+++ /dev/null
@@ -1,27 +0,0 @@
-#include "ColorSensor.h"
-#include "Arduino.h"
-ColorSensor colorSensor;
-
-void setup() {
-    colorSensor = ColorSensor();
-}
-
-void loop()	{
-    Serial.begin(115200);
-    Serial.print("\n\n\n\n\n");
-
-   int colorResult = colorSensor.getColor();
-
-      /*  --- For Testing --- */
-   if(colorResult == 0) {
-      Serial.print("\n WHITE \n");
-   } else if(colorResult == 1) {
-      Serial.print("\n BLACK \n");
-   } else if(colorResult == 2) {
-      Serial.print("\n BLUE \n");
-   } else {
-      Serial.print("\n UN SURE \n");
-   }
-
-    delay(2000);
-}
\ No newline at end of file
diff --git a/ROBOT_2014/TestingGround/Color Sensor/colorSensorPulseReader/BackEndColorSensor.h b/ROBOT_2014/TestingGround/Color Sensor/colorSensorPulseReader/BackEndColorSensor.h
index df2d24b..0ed8835 100755
--- a/ROBOT_2014/TestingGround/Color Sensor/colorSensorPulseReader/BackEndColorSensor.h	
+++ b/ROBOT_2014/TestingGround/Color Sensor/colorSensorPulseReader/BackEndColorSensor.h	
@@ -10,4 +10,4 @@ class BackEndColorSensor
         void TCS3200setup();
 };
 
-#endif // BACKENDCOLORSENSOR_H
+#endif //BACKENDCOLORSENSOR_H
diff --git a/ROBOT_2014/TestingGround/Color Sensor/colorSensorPulseReader/colorSensor.h b/ROBOT_2014/TestingGround/Color Sensor/colorSensorPulseReader/colorSensor.h
index ea82549..658bfcf 100644
--- a/ROBOT_2014/TestingGround/Color Sensor/colorSensorPulseReader/colorSensor.h	
+++ b/ROBOT_2014/TestingGround/Color Sensor/colorSensorPulseReader/colorSensor.h	
@@ -10,12 +10,12 @@ class ColorSensor
         int getColor();
     private:
         void TCS3200setup();
-        int S0;//pinB //digital
-        int S1;//pinA //26 on other //digital
-        int S2;//pinE //30 on other //digital
-        int S3;//pinF //34 on other //digital
-        int taosOutPin;//pinC //38 on other
-        int LED;//pinD //42 on other
+        int S0;//pinB //31 on other //digital
+        int S1;//pinA //33 on other //digital
+        int S2;//pinE //37 on other //digital
+        int S3;//pinF //39 on other //digital
+        int taosOutPin;//pinC //41 on other
+        int LED;//pinD //43 on other
         bool LEDstate; //LED is turned on
         
 };
diff --git a/ROBOT_2014/TestingGround/demo/SPI.cpp b/ROBOT_2014/TestingGround/demo/SPI.cpp
deleted file mode 100644
index 5e48073..0000000
--- a/ROBOT_2014/TestingGround/demo/SPI.cpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2010 by Cristian Maglie <c.maglie@bug.st>
- * SPI Master library for arduino.
- *
- * This file is free software; you can redistribute it and/or modify
- * it under the terms of either the GNU General Public License version 2
- * or the GNU Lesser General Public License version 2.1, both as
- * published by the Free Software Foundation.
- */
-
-#include "pins_arduino.h"
-#include "SPI.h"
-
-SPIClass SPI;
-
-void SPIClass::begin() {
-
-  // Set SS to high so a connected chip will be "deselected" by default
-  digitalWrite(SS, HIGH);
-
-  // When the SS pin is set as OUTPUT, it can be used as
-  // a general purpose output port (it doesn't influence
-  // SPI operations).
-  pinMode(SS, OUTPUT);
-
-  // Warning: if the SS pin ever becomes a LOW INPUT then SPI
-  // automatically switches to Slave, so the data direction of
-  // the SS pin MUST be kept as OUTPUT.
-  SPCR |= _BV(MSTR);
-  SPCR |= _BV(SPE);
-
-  // Set direction register for SCK and MOSI pin.
-  // MISO pin automatically overrides to INPUT.
-  // By doing this AFTER enabling SPI, we avoid accidentally
-  // clocking in a single bit since the lines go directly
-  // from "input" to SPI control.  
-  // http://code.google.com/p/arduino/issues/detail?id=888
-  pinMode(SCK, OUTPUT);
-  pinMode(MOSI, OUTPUT);
-}
-
-
-void SPIClass::end() {
-  SPCR &= ~_BV(SPE);
-}
-
-void SPIClass::setBitOrder(uint8_t bitOrder)
-{
-  if(bitOrder == LSBFIRST) {
-    SPCR |= _BV(DORD);
-  } else {
-    SPCR &= ~(_BV(DORD));
-  }
-}
-
-void SPIClass::setDataMode(uint8_t mode)
-{
-  SPCR = (SPCR & ~SPI_MODE_MASK) | mode;
-}
-
-void SPIClass::setClockDivider(uint8_t rate)
-{
-  SPCR = (SPCR & ~SPI_CLOCK_MASK) | (rate & SPI_CLOCK_MASK);
-  SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | ((rate >> 2) & SPI_2XCLOCK_MASK);
-}
-
diff --git a/ROBOT_2014/TestingGround/demo/SPI.h b/ROBOT_2014/TestingGround/demo/SPI.h
deleted file mode 100644
index f647d5c..0000000
--- a/ROBOT_2014/TestingGround/demo/SPI.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (c) 2010 by Cristian Maglie <c.maglie@bug.st>
- * SPI Master library for arduino.
- *
- * This file is free software; you can redistribute it and/or modify
- * it under the terms of either the GNU General Public License version 2
- * or the GNU Lesser General Public License version 2.1, both as
- * published by the Free Software Foundation.
- */
-
-#ifndef _SPI_H_INCLUDED
-#define _SPI_H_INCLUDED
-
-#include <stdio.h>
-#include <Arduino.h>
-#include <avr/pgmspace.h>
-
-#define SPI_CLOCK_DIV4 0x00
-#define SPI_CLOCK_DIV16 0x01
-#define SPI_CLOCK_DIV64 0x02
-#define SPI_CLOCK_DIV128 0x03
-#define SPI_CLOCK_DIV2 0x04
-#define SPI_CLOCK_DIV8 0x05
-#define SPI_CLOCK_DIV32 0x06
-//#define SPI_CLOCK_DIV64 0x07
-
-#define SPI_MODE0 0x00
-#define SPI_MODE1 0x04
-#define SPI_MODE2 0x08
-#define SPI_MODE3 0x0C
-
-#define SPI_MODE_MASK 0x0C  // CPOL = bit 3, CPHA = bit 2 on SPCR
-#define SPI_CLOCK_MASK 0x03  // SPR1 = bit 1, SPR0 = bit 0 on SPCR
-#define SPI_2XCLOCK_MASK 0x01  // SPI2X = bit 0 on SPSR
-
-class SPIClass {
-public:
-  inline static byte transfer(byte _data);
-
-  // SPI Configuration methods
-
-  inline static void attachInterrupt();
-  inline static void detachInterrupt(); // Default
-
-  static void begin(); // Default
-  static void end();
-
-  static void setBitOrder(uint8_t);
-  static void setDataMode(uint8_t);
-  static void setClockDivider(uint8_t);
-};
-
-extern SPIClass SPI;
-
-byte SPIClass::transfer(byte _data) {
-  SPDR = _data;
-  while (!(SPSR & _BV(SPIF)))
-    ;
-  return SPDR;
-}
-
-void SPIClass::attachInterrupt() {
-  SPCR |= _BV(SPIE);
-}
-
-void SPIClass::detachInterrupt() {
-  SPCR &= ~_BV(SPIE);
-}
-
-#endif
diff --git a/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/BackEndColorSensor.h b/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/BackEndColorSensor.h
new file mode 100644
index 0000000..1c5202e
--- /dev/null
+++ b/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/BackEndColorSensor.h
@@ -0,0 +1,13 @@
+#ifndef BACKENDCOLORSENSOR_H
+#define BACKENDCOLORSENSOR_H
+#include <Arduino.h>
+class BackEndColorSensor
+{
+    public:
+        BackEndColorSensor(); //Nescessary color sensor setup called in constructor
+        int colorRead(int color);
+    private:
+        void TCS3200setup();
+};
+
+#endif //BACKENDCOLORSENSOR_H
diff --git a/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/colorPulseValues.txt b/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/colorPulseValues.txt
new file mode 100644
index 0000000..fa0b758
--- /dev/null
+++ b/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/colorPulseValues.txt
@@ -0,0 +1,151 @@
+
+White2380
+ Blue6858
+ Red:8906
+ Green:8071
+
+
+
+
+White708
+ Blue1999
+ Red:2912
+ Green:3496
+
+
+
+
+White512
+ Blue1289
+ Red:1481
+ Green:1356
+
+
+
+
+White267
+ Blue648
+ Red:745
+ Green:816
+
+
+
+
+White386
+ Blue952
+ Red:1005
+ Green:1011
+
+
+
+
+White132
+ Blue363
+ Red:321
+ Green:398
+
+
+
+
+
+ White--------------------------------------------------------------------------------------------------------
+
+
+White8
+ Blue25
+ Red:29
+ Green:43
+
+
+
+
+White7
+ Blue25
+ Red:28
+ Green:28
+
+
+
+
+White4
+ Blue19
+ Red:18
+ Green:20
+
+
+
+
+White6
+ Blue20
+ Red:19
+ Green:22
+
+
+
+
+White6
+ Blue19
+ Red:18
+ Green:20
+
+
+
+
+
+ --------------------------------------------------------------- BLUE
+
+
+ White157
+ Blue620
+ Red:221
+ Green:377
+
+
+
+
+White49
+ Blue264
+ Red:74
+ Green:150
+
+
+
+
+White46
+ Blue310
+ Red:67
+ Green:148
+
+
+
+
+White45
+ Blue348
+ Red:74
+ Green:154
+
+
+
+
+White52
+ Blue410
+ Red:81
+ Green:162
+
+
+
+
+White41
+ Blue283
+ Red:64
+ Green:142
+
+
+
+
+White: 41
+ Blue229
+ Red:69
+ Green:159
+
+
diff --git a/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/colorSensor.cpp b/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/colorSensor.cpp
new file mode 100644
index 0000000..4dd1a22
--- /dev/null
+++ b/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/colorSensor.cpp
@@ -0,0 +1,139 @@
+#include "ColorSensor.h"
+/*Pin Constants */
+
+
+
+
+
+/**
+ * calls the setUp method for the TC3200 sensor
+ */
+ColorSensor::ColorSensor()
+{}
+
+
+/**
+ * Public method called on from the ColorSensor class
+ * @param color : the desried color to pulse read
+                    0 = white
+                    1 = blue
+                    2 = red
+                    3 = green
+ *
+ * @returns the pulse of the desired color
+ */
+ 
+void ColorSensor::setup(int S0, int S1, int S2, int S3, int out, int LED)
+{
+    this->S0 = S0;
+    this->S1 = S1;
+    this->S2 = S2;
+    this->S3 = S3;
+    this->taosOutPin = out;
+    this->LED = LED;
+}
+
+int ColorSensor::colorRead(int color)    {
+
+    //set the S2 and S3 pins to select the color to be sensed
+    if(color == 0){//white
+        digitalWrite(S3, LOW); //S3
+        digitalWrite(S2, HIGH); //S2
+        // Serial.print(" w");
+    }
+
+    else if(color == 1){//red
+        digitalWrite(S3, LOW); //S3
+        digitalWrite(S2, LOW); //S2
+        // Serial.print(" r");
+    }
+
+    else if(color == 2){//blue
+        digitalWrite(S3, HIGH); //S3
+        digitalWrite(S2, LOW); //S2
+        // Serial.print(" b");
+    }
+
+    else if(color == 3){//green
+        digitalWrite(S3, HIGH); //S3
+        digitalWrite(S2, HIGH); //S2
+        // Serial.print(" g");
+    }
+
+    int readPulse; //where the pulse reading from sensor will go
+
+    
+
+    delay(100); //Delay for 100ms for before reading
+
+    // now take a measurement from the sensor, timing a low pulse on the sensor's "out" pin
+    readPulse = int(pulseIn(taosOutPin, LOW, 80000));
+
+    //if the pulseIn times out, it returns 0 and that throws off numbers, so set any to 1.
+    if(readPulse < 1){
+        readPulse = 1;
+    }
+
+    // return the pulse value back to whatever called for it...
+    return readPulse;
+}
+
+/**
+  * Setup for the Sensor
+  */
+void ColorSensor::TCS3200setup()   {
+    //initialize pins
+    pinMode(LED,OUTPUT); //LED pinD
+
+    //color mode selection
+    pinMode(S2,OUTPUT); //S2 pinE
+    pinMode(S3,OUTPUT); //s3 pinF
+
+    //color response pin (only actual input from taos)
+    pinMode(taosOutPin, INPUT); //taosOutPin pinC
+
+    //communication freq (sensitivity) selection
+    pinMode(S0,OUTPUT); //S0 pinB
+    pinMode(S1,OUTPUT); //S1 pinA
+
+    //this will put in 1:1, highest sensitivity
+    digitalWrite(S0, HIGH); //S0
+    digitalWrite(S1, HIGH); //S1
+    
+    digitalWrite(LED, HIGH);
+    
+    return;
+}
+
+/**
+  * Return values:
+  *     0 = White
+  *     1 = Black
+  *     2 = Blue
+  *     3 = Un-sure
+  */
+int ColorSensor::getColor() {
+    int whiteVal = colorRead(0);
+    int redVal = colorRead(2);
+    int greenVal = colorRead(3);
+    int blueVal = colorRead(1);
+
+    if(blueVal > redVal && blueVal + greenVal + redVal > 70) {
+        return 2;
+    }
+
+    else if(blueVal + greenVal + redVal < 60) {
+        return 0;
+    }
+
+    else if(blueVal + greenVal + redVal > 70) {
+        return 1;
+    }
+
+    else { //Un-sure of color
+        return 3;
+    }
+}
+
+
+
diff --git a/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/colorSensor.h b/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/colorSensor.h
new file mode 100644
index 0000000..e017088
--- /dev/null
+++ b/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/colorSensor.h
@@ -0,0 +1,24 @@
+#ifndef COLORSENSOR_H
+#define COLORSENSOR_H
+#include <Arduino.h>
+class ColorSensor
+{
+   
+    public:
+        ColorSensor(); //Nescessary color sensor setup called in constructor
+        void setup(int S0, int S1, int S2, int S3, int out, int LED);
+        int colorRead(int color);
+        int getColor();
+    private:
+        void TCS3200setup();
+        int S0;//pinB //22 on other //digital
+        int S1;//pinA //26 on other //digital
+        int S2;//pinE //30 on other //digital
+        int S3;//pinF //34 on other //digital
+        int taosOutPin;//pinC //38 on other
+        int LED;//pinD //42 on other
+        bool LEDstate; //LED is turned on
+        
+};
+
+#endif // COLORSENSOR_H
diff --git a/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/colorSensorPulseReader.ino b/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/colorSensorPulseReader.ino
new file mode 100644
index 0000000..b9c1198
--- /dev/null
+++ b/ROBOT_2014/TestingGround/demo/colorSensorPulseReader/colorSensorPulseReader.ino
@@ -0,0 +1,27 @@
+#include "ColorSensor.h"
+#include "Arduino.h"
+ColorSensor colorSensor;
+
+void setup() {
+    colorSensor = ColorSensor();
+}
+
+void loop()	{
+    Serial.begin(115200);
+    Serial.print("\n\n\n\n\n");
+
+   int colorResult = colorSensor.getColor();
+
+      /*  --- For Testing --- */
+   if(colorResult == 0) {
+      Serial.print("\n WHITE \n");
+   } else if(colorResult == 1) {
+      Serial.print("\n BLACK \n");
+   } else if(colorResult == 2) {
+      Serial.print("\n BLUE \n");
+   } else {
+      Serial.print("\n UN SURE \n");
+   }
+
+    delay(2000);
+}
\ No newline at end of file
diff --git a/ROBOT_2014/TestingGround/demo/demo.ino b/ROBOT_2014/TestingGround/demo/demo.ino
index 4171bc0..1c84236 100644
--- a/ROBOT_2014/TestingGround/demo/demo.ino
+++ b/ROBOT_2014/TestingGround/demo/demo.ino
@@ -1,5 +1,7 @@
+#include <pins.h>
 #include <motors.h>
 #include <linefollow.hpp>
+#include <colorSensor.h>
 
 //enum State { MAIN_LINE = 1, STRAIGHT_LINE_START, FIRE, STRAIGHT_LINE_END, CURVED_LINE_START, CURVED_LINE_END };
 
@@ -12,79 +14,50 @@ typedef enum
 //Hardware interfaces
 static Motors motors;
 static LineFollower lineFollower;
+static ColorSensor cs;
 
-//
-//static State state;
 static j_state j_s = FOLLOW_STRAIGHT_LINE;
 static byte leftLineFollowBits;
 static byte rightLineFollowBits;
 static int lineCount;
 
-//Line Sensor pins
-static const short Load    = 22; // Controls ShiftRegister's Shift/Load pin(1)
-static const short sensor  = 24; // Controls LineFollower's Enable pin
-static const short L_side_pin = 10; // PWM pin for left trek
-static const short R_side_pin = 9;  // PWM pin for right trek
-static const short Dir_Right_Side  =  30; // Controls direction of the right track(LOW - forward, HIGH - Reverse)
-static const short Dir_Left_Side  =   31; // Controls direction of the left track (LOW - forward, HIGH - Reverse)
-
 //Setup variables etc
 void setup() {
 
 	Serial.begin(9600);
-	delay(4000);
-	Serial.print("BEGINNING\n");
-	//init all hardware
-	motors.setup(255);
-	motors.motorsStop();
+	Serial.println("IN the beginning...");
+	//Initialize Hardware--------------------------------
+	//Motor variables setup
+	motors.setup(PIN_PWM_LEFT, PIN_DIRECTION_LEFT, PIN_PWM_RIGHT, PIN_DIRECTION_RIGHT, DEFAULT_SPEED);
 	//LineFollower variables setup
+	lineFollower.setup(PIN_LOAD, PIN_SENSOR);
 	SPI.begin();
 	SPI.setClockDivider(SPI_CLOCK_DIV2);
 	SPI.setDataMode(SPI_MODE3);
 	SPI.setBitOrder(MSBFIRST);
 
-	pinMode(Load, OUTPUT);
-	digitalWrite(Load, HIGH);
-	pinMode(sensor, OUTPUT);
-	digitalWrite(sensor, HIGH); //activates LineFollower Kit
-
-	pinMode(L_side_pin, OUTPUT);
-	pinMode(R_side_pin, OUTPUT);
-	pinMode(Dir_Right_Side, OUTPUT);
-	pinMode(Dir_Left_Side, OUTPUT);
+	pinMode(PIN_LOAD, OUTPUT);
+	digitalWrite(PIN_LOAD, HIGH);
+	pinMode(PIN_SENSOR, OUTPUT);
+	digitalWrite(PIN_SENSOR, HIGH); //activates LineFollower Kit
 
 	//Variables setup
 	//state = MAIN_LINE;
 	lineCount = 0;
-	Serial.print("Delaying....\n");
-	Serial.print("STOPP....\n");
-	motors.motorsStop();
-	delay(5000);
+    cs.setup(CS_S0, CS_S1, CS_S2, CS_S3, CS_OUT, CS_LED);
+
+    //Loop until start
+    while(!(digitalRead(PIN_START) == LOW))
+    Serial.println("GO!");
 }
 
 //Loop
 void loop() {
 
-  /*
-	Serial.print("STOPP....\n");
-	motors.motorsStop();
-	Serial.println("Going Forward");
-	motors.motorsDrive(FORWARD);
-	delay(3000);
-	Serial.println("Going Backward");
-	motors.motorsDrive(BACKWARD);
-	delay(3000);
-	Serial.println("Turning Left");
-	motors.motorsTurnLeft();
-	delay(3000);
-	Serial.println("Turning RIGHT");
-	motors.motorsTurnRight();
-	delay(3000);
-*/
-
-switch (j_s)
-{
+	switch (j_s)
+	{
         case FOLLOW_STRAIGHT_LINE:
+        	
             if (lineFollower.intersection(leftLineFollowBits, rightLineFollowBits))
             {
                 j_s = TURN_LEFT; break; 
@@ -95,16 +68,21 @@ switch (j_s)
             }
             else
             {
-                if (!lineFollower.isCentered(leftLineFollowBits, rightLineFollowBits) &&(leftLineFollowBits > rightLineFollowBits))
+                if (!lineFollower.isCentered(leftLineFollowBits, rightLineFollowBits) && (leftLineFollowBits > rightLineFollowBits)) {
+                	//Serial.println("NOT CENTERED, leftLineFollowBits > rightLineFollowBits");
                     motors.motorsTurnLeft();
-                if (!lineFollower.isCentered(leftLineFollowBits, rightLineFollowBits) &&(leftLineFollowBits < rightLineFollowBits))
+                }
+                else if (!lineFollower.isCentered(leftLineFollowBits, rightLineFollowBits) && (leftLineFollowBits < rightLineFollowBits)) {
+                	//Serial.println("NOT CENTERED, rightLineFollowBits > leftLineFollowBits");
                     motors.motorsTurnRight(); 
+                }
                 j_s = FOLLOW_STRAIGHT_LINE; break;
             }
          case TURN_LEFT:
+         	//Serial.println("Turn Left");
              do {
-                 motors.motorsDrive(FORWARD);
-                 delay(500);
+             	 motors.motorsDrive(FORWARD);
+             	 delay(500);
                  motors.motorsTurnLeft();
                  delay(500);
                  lineFollower.Get_Line_Data(leftLineFollowBits, rightLineFollowBits);
@@ -113,20 +91,14 @@ switch (j_s)
              do {
                  motors.motorsTurnLeft();
                  lineFollower.Get_Line_Data(leftLineFollowBits, rightLineFollowBits);
-             } while (leftLineFollowBits || rightLineFollowBits);
-             
-             do {
-                 motors.motorsTurnLeft();
-                 lineFollower.Get_Line_Data(leftLineFollowBits, rightLineFollowBits);
              } while (!leftLineFollowBits && !rightLineFollowBits);
-             
+             //Serial.println("Back to the straight line state");
              j_s = FOLLOW_STRAIGHT_LINE;
              break;
 }
 
 
 /*	switch(state) {
-
 		case MAIN_LINE:
 			Serial.println("MAIN LINE");
 			motors.motorsDrive(FORWARD);
@@ -204,6 +176,7 @@ switch (j_s)
 */
 }
 
+/*
 void followTheLine(byte leftBits, byte rightBits)
 {
 	short leftPWM = 0;
@@ -231,6 +204,6 @@ void followTheLine(byte leftBits, byte rightBits)
                 motors.motorsDrive(FORWARD);
 	}
 
-
 	return;
 }
+*/
\ No newline at end of file
diff --git a/ROBOT_2014/TestingGround/demo/lib/linefollow.cpp b/ROBOT_2014/TestingGround/demo/lib/linefollow.cpp
index 9012e62..ef4503e 100644
--- a/ROBOT_2014/TestingGround/demo/lib/linefollow.cpp
+++ b/ROBOT_2014/TestingGround/demo/lib/linefollow.cpp
@@ -2,7 +2,8 @@
 
 //#define DEBUG
 
-LineFollower::LineFollower()
+void LineFollower::setup(unsigned short loadPin, 
+                            unsigned short sensorPin)
 {
   #ifdef DEBUG_STANDALONE
   Gate_flag = 0;
@@ -11,6 +12,8 @@ LineFollower::LineFollower()
   Hor_Line_pass = 1;
   #endif
   Line_Data = 0;
+  Load = loadPin;
+  sensor = sensorPin;
 }
 
 //**************  Evaluate whether the robot is centered on the line **********
@@ -21,7 +24,7 @@ bool LineFollower::isCentered(byte& L_bits, byte& R_bits) // Has to be changed a
    L_bits = this->L_bits;
    R_bits = this->R_bits;
 
-   return (L_bits == R_bits); //L_bits == R_bits is ambiguous as it also happens when rover is over black part of the course (L_bits==R_bits == 0)
+   return (L_bits == R_bits) && (L_bits == 1); //L_bits == R_bits is ambiguous as it also happens when rover is over black part of the course (L_bits==R_bits == 0)
 }
 
 //**************  Evaluate whether the robot is on an intersecting line *******
@@ -31,6 +34,7 @@ bool LineFollower::intersection(byte& L_bits, byte& R_bits)
   Get_Line_Data();
   L_bits = this->L_bits;
   R_bits = this->R_bits;
+
   return ( Line_Data == 0xFF );
 }
 
diff --git a/ROBOT_2014/TestingGround/demo/lib/linefollow.hpp b/ROBOT_2014/TestingGround/demo/lib/linefollow.hpp
index 053d388..1a7425e 100644
--- a/ROBOT_2014/TestingGround/demo/lib/linefollow.hpp
+++ b/ROBOT_2014/TestingGround/demo/lib/linefollow.hpp
@@ -42,8 +42,12 @@
 class LineFollower
 {
 private:
-	static const short Load    = 22; // Controls ShiftRegister's Shift/Load pin(1)
-	static const short sensor  = 24; // Controls LineFollower's Enable pin
+	unsigned short Load; // Controls ShiftRegister's Shift/Load pin(1)
+	unsigned short sensor; // Controls LineFollower's Enable pin
+
+	byte L_bits;
+	byte R_bits;
+	byte Line_Data;
 
 	#ifdef DEBUG_STANDALONE
 	static const short L_side_pin = 10; // PWM pin for left trek
@@ -51,13 +55,7 @@ private:
 	static const short Dir_Right_Side  =  30; // Controls direction of the right track(LOW - forward, HIGH - Reverse)
 	static const short Dir_Left_Side  =   31; // Controls direction of the left track (LOW - forward, HIGH - Reverse)
 	static const byte max_speed = 100;   // PWM value 0-255
-	#endif
-	
-	byte L_bits;
-	byte R_bits;
-	byte Line_Data;
-	
-	#ifdef DEBUG_STANDALONE
+
 	short L_PWM;
 	short R_PWM;
 	short Gate_flag;
@@ -84,7 +82,8 @@ private:
 	void Halt();
 	#endif
 public:
-	LineFollower();
+	void setup(unsigned short loadPin, 
+				unsigned short sensorPin);
 	bool isCentered(byte& L_bits, byte& R_bits);
 	bool intersection(byte& L_bits, byte& R_bits);
 	void Get_Line_Data(byte& L_bits, byte& R_bits);
diff --git a/ROBOT_2014/TestingGround/demo/lib/motors.cpp b/ROBOT_2014/TestingGround/demo/lib/motors.cpp
index bffabd4..cdf82dd 100644
--- a/ROBOT_2014/TestingGround/demo/lib/motors.cpp
+++ b/ROBOT_2014/TestingGround/demo/lib/motors.cpp
@@ -1,22 +1,46 @@
 #include "motors.h"
 
 //Sets up the pin modes and the default speed.
-void Motors::setup(int defaultSpeed) {
+void Motors::setup(unsigned short pwmPinLeft, unsigned short directionPinLeft, 
+                unsigned short pwmPinRight, unsigned short directionPinRight, 
+                unsigned int defaultSpeed) {
+
+    delay(2);
+
+    pinMode(PWM_LEFT, OUTPUT);
+    pinMode(DIRECTION_LEFT, OUTPUT);
+
+    pinMode(PWM_RIGHT, OUTPUT);
+    pinMode(DIRECTION_RIGHT, OUTPUT);
+
+    PWM_LEFT = pwmPinLeft;
+    DIRECTION_LEFT = directionPinLeft;
+    PWM_RIGHT = pwmPinRight;
+    DIRECTION_RIGHT = directionPinRight;
+
+    speed = defaultSpeed;
+    flipDirection = false;
+
+    delay(2);
+}
+
+//Sets up the pin modes and the default speed.
+/*void Motors::setup(int defaultSpeed) {
 
     delay(2);
 
     //Set the PIN Modes
-    pinMode(PIN_PWM_LEFT, OUTPUT);
-    pinMode(PIN_DIRECTION_LEFT, OUTPUT);
+    pinMode(PWM_LEFT, OUTPUT);
+    pinMode(DIRECTION_LEFT, OUTPUT);
 
-    pinMode(PIN_PWM_RIGHT, OUTPUT);
-    pinMode(PIN_DIRECTION_RIGHT, OUTPUT);
+    pinMode(PWM_RIGHT, OUTPUT);
+    pinMode(DIRECTION_RIGHT, OUTPUT);
 
     speed = defaultSpeed;
 
     //Delay 2 milliseconds so we don't explode....
     delay(2);
-}
+}*/
 
 /*
  * Drives the motors in the direction passed in. The Enum Direction has FORWARD, and BACKWARD as values.
@@ -31,49 +55,42 @@ void Motors::motorsDrive(Direction motorsDirection) {
  
     if (motorsDirection == FORWARD) {
         pinInput = HIGH;
-        Serial.print("pinInput is HIGH!\n");
     }
     else {
         pinInput = LOW;
-        Serial.print("pinInput is LOW!\n");
     }
 
-    digitalWrite(PIN_DIRECTION_LEFT, pinInput);
-    analogWrite(PIN_PWM_LEFT, speed);   
+    digitalWrite(DIRECTION_LEFT, pinInput);
+    analogWrite(PWM_LEFT, speed);   
 
-    digitalWrite(PIN_DIRECTION_RIGHT, !pinInput);
-    analogWrite(PIN_PWM_RIGHT, speed);
+    digitalWrite(DIRECTION_RIGHT, !pinInput);
+    analogWrite(PWM_RIGHT, speed);
 
     //Delay 2 milliseconds so we don't explode....
     delay(2);
 }
 
 //Adjust the speed of each motor manually by passing a PWM 
-void Motors::motorsTurn(short leftPWM, short rightPWM, Turn motorsTurn) {
+/*void Motors::motorsTurn(short leftPWM, short rightPWM, Turn motorsTurn) {
 
     delay(2);
 
-    bool pinInput1, pinInput2;
+    bool pinInput;
 
     if (motorsTurn == RIGHT) {
-        pinInput1 = LOW;
+        pinInput = LOW;
     }
     else if (motorsTurn == LEFT) {
-        pinInput1 = HIGH;
-    }
-    else {
-        Serial.println("WTF....");
-        pinInput1 = HIGH;
-        pinInput2 = LOW;
+        pinInput = HIGH;
     }
 
-    digitalWrite(PIN_DIRECTION_LEFT, pinInput1);
-    digitalWrite(PIN_DIRECTION_RIGHT, pinInput2);
-    analogWrite(PIN_PWM_LEFT, leftPWM);
-    analogWrite(PIN_PWM_RIGHT, rightPWM);
+    digitalWrite(DIRECTION_LEFT, pinInput);
+    digitalWrite(DIRECTION_RIGHT, pinInput);
+    analogWrite(PWM_LEFT, leftPWM);
+    analogWrite(PWM_RIGHT, rightPWM);
 
     delay(2);
-}
+}*/
 
 //
 void Motors::motorsUTurn() {
@@ -113,22 +130,25 @@ void Motors::motorsTurnRight() {
 
 //Turns the motors in the specified direction (used to make the above methods work, not to be interfaced with)
 void Motors::motorsTurn(Turn motorsTurn){
-
     //Delay 2 milliseconds so we don't explode....
     delay(2);
 
     bool pinInput;
 
-    if (motorsTurn == RIGHT) 
+    if (motorsTurn == RIGHT) {
         pinInput = LOW;
-    else
+        //Serial.println("motorsTurnLeft");
+    }
+    else {
         pinInput = HIGH;
+        //Serial.println("motorsTurnRight");
+    }
 
-    digitalWrite(PIN_DIRECTION_LEFT, pinInput);
-    analogWrite(PIN_PWM_LEFT, speed);   
+    digitalWrite(DIRECTION_LEFT, pinInput);
+    analogWrite(PWM_LEFT, speed);   
 
-    digitalWrite(PIN_DIRECTION_RIGHT, pinInput);
-    analogWrite(PIN_PWM_RIGHT, speed);   
+    digitalWrite(DIRECTION_RIGHT, pinInput);
+    analogWrite(PWM_RIGHT, speed);   
 
     //Delay 2 milliseconds so we don't explode....
     delay(2);
@@ -140,9 +160,9 @@ void Motors::motorsStop() {
     //Delay 2 milliseconds so we don't explode....
     delay(2);
 
-    analogWrite(PIN_PWM_LEFT, 0);  
-    analogWrite(PIN_PWM_RIGHT, 0);  
+    analogWrite(PWM_LEFT, 0);  
+    analogWrite(PWM_RIGHT, 0);  
 
     //Delay 2 milliseconds so we don't explode....
     delay(2);
-}
+}
\ No newline at end of file
diff --git a/ROBOT_2014/TestingGround/demo/lib/motors.h b/ROBOT_2014/TestingGround/demo/lib/motors.h
index 0dab85a..29f83a2 100644
--- a/ROBOT_2014/TestingGround/demo/lib/motors.h
+++ b/ROBOT_2014/TestingGround/demo/lib/motors.h
@@ -5,15 +5,17 @@
 
 //Define the Pins----------
 //Motor Pair 1 (ON THE LEFT SIDE)
-#define PIN_DIRECTION_LEFT 26 //Direction
-#define PIN_PWM_LEFT 3 //Speed
+/*
+#define DIRECTION_LEFT 26 //Direction
+#define PWM_LEFT 3 //Speed
 
 //Motor Pair 2 (ON THE RIGHT SIDE)
-#define PIN_DIRECTION_RIGHT 28 //Direction
-#define PIN_PWM_RIGHT 4 //Speed
+#define DIRECTION_RIGHT 28 //Direction
+#define PWM_RIGHT 4 //Speed
+*/
 
 //Enum for specifying direction to move in
-enum Direction { FORWARD = 1, BACKWARD, NONE };
+enum Direction { FORWARD = 1, BACKWARD };
 
 //Enum for specifying the direction to turn in
 enum Turn {	LEFT = 1, RIGHT };
@@ -27,24 +29,33 @@ class Motors
 	/*
 		Connections:
 		- Pin 3 ---> PWM for left motors
-		- Pin 8 ---> PIN_DIRECTION_LEFT
+		- Pin 8 ---> DIRECTION_LEFT
 
 		- Pin 4 ---> PWM for right motors
-		- Pin 9 ---> PIN_DIRECTION_RIGHT
+		- Pin 9 ---> DIRECTION_RIGHT
 	*/
 	//==================================================
 
 	public:
-		void setup(int defaultSpeed);
+		void setup(unsigned short pwmPinLeft, 
+					unsigned short directionPinLeft, 
+					unsigned short pwmPinRight, 
+					unsigned short directionPinRight, 
+					unsigned int defaultSpeed);
 		void motorsDrive(Direction motorsDirection);
 		void motorsStop();
 		void motorsTurnLeft();
 		void motorsTurnRight();
 		void motorsTurn(Turn motorsTurn);
-		void motorsTurn(short leftPWM, short rightPWM);
+		//void motorsTurn(short leftPWM, short rightPWM);
 		void motorsUTurn();
 		int speed;
+		bool flipDirection;
 	private:
-		void motorsTurn(short leftPWM, short rightPWM, Turn motorsTurn);
+		//void motorsTurn(short leftPWM, short rightPWM, Turn motorsTurn);
+		unsigned short PWM_LEFT;
+		unsigned short PWM_RIGHT;
+		unsigned short DIRECTION_LEFT;
+		unsigned short DIRECTION_RIGHT;
 };
 #endif
\ No newline at end of file
diff --git a/ROBOT_2014/TestingGround/demo/lib/pins.h b/ROBOT_2014/TestingGround/demo/lib/pins.h
index 9f45705..f2a1151 100644
--- a/ROBOT_2014/TestingGround/demo/lib/pins.h
+++ b/ROBOT_2014/TestingGround/demo/lib/pins.h
@@ -1,25 +1,28 @@
 #ifndef PIN_DEFINITIONS_H_
 #define PIN_DEFINITIONS_H_
 
-//Pin assignments--------------------------
-
+//Motor Pins---------------------------------------
 //Motor Pair 1 (ON THE LEFT SIDE)
-#define PIN_DIRECTION_LEFT 8 //Direction
-#define PIN_PWM_LEFT 3 //Speed
+static const unsigned short PIN_DIRECTION_LEFT = 26; //Direction
+static const unsigned short PIN_PWM_LEFT = 3; //Speed
 //Motor Pair 2 (ON THE RIGHT SIDE)
-#define PIN_DIRECTION_RIGHT 9 //Direction
-#define PIN_PWM_RIGHT 4 //Speed
+static const unsigned short PIN_DIRECTION_RIGHT = 28; //Direction
+static const unsigned short PIN_PWM_RIGHT = 4; //Speed
+static const unsigned int DEFAULT_SPEED = 255;
+
+//Line Sensor Pins--------------------------------
+static const unsigned short PIN_LOAD = 22; // Controls ShiftRegister's Shift/Load pin(1)
+static const unsigned short PIN_SENSOR = 24; // Controls LineFollower's Enable pin
 
-//Line Sensor Pins
-#define Load 22 // Controls ShiftRegister's Shift/Load pin(1)
-#define sensor 24 // Controls LineFollower's Enable pin
+//Color Sensor Pins-------------------------------
+static const unsigned short CS_S0 = 31;
+static const unsigned short CS_S1 = 33;
+static const unsigned short CS_S2 = 37;
+static const unsigned short CS_S3 = 39;
+static const unsigned short CS_OUT = 41;
+static const unsigned short CS_LED = 43;
 
-//Color Sensor pins
-#define CS_S0 25
-#define CS_S1 26
-#define CS_S2 30
-#define CS_S3 34
-#define CS_OUT 38
-#define CS_LED 42
+//Start Button
+static const unsigned short PIN_START = 42;
 
 #endif
diff --git a/ROBOT_2014/TestingGround/demo/linefollow.cpp b/ROBOT_2014/TestingGround/demo/linefollow.cpp
deleted file mode 100644
index 1d9690c..0000000
--- a/ROBOT_2014/TestingGround/demo/linefollow.cpp
+++ /dev/null
@@ -1,270 +0,0 @@
-#include "C:\Users\ethan\Documents\ACTUAL My Documents\Robotics Team\IEEE-Robotics\ROBOT_2014\TestingGround\demo\linefollow.hpp"
-
-//#define DEBUG
-
-LineFollower::LineFollower()
-{
-  #ifdef DEBUG_STANDALONE
-  Gate_flag = 0;
-  U_Turn_flag = 0;
-  Num_LT = 0;
-  Hor_Line_pass = 1;
-  #endif
-  Line_Data = 0;
-}
-
-//**************  Evaluate whether the robot is centered on the line **********
-
-bool LineFollower::isCentered(byte& L_bits, byte& R_bits) // Has to be changed as the code doesn't explicitly checks whether it(rover) is centered or not.
-{
-   Get_Line_Data();
-   L_bits = this->L_bits;
-   R_bits = this->R_bits;
-
-   return (L_bits == R_bits) && (L_bits == 1); //L_bits == R_bits is ambiguous as it also happens when rover is over black part of the course (L_bits==R_bits == 0)
-}
-
-//**************  Evaluate whether the robot is on an intersecting line *******
-
-bool LineFollower::intersection(byte& L_bits, byte& R_bits)
-{
-  Get_Line_Data();
-  L_bits = this->L_bits;
-  R_bits = this->R_bits;
-  return ( Line_Data == 0xFF );
-}
-
-
-//*************** Get Data from 8-bit Shift Register***************************
-
-void LineFollower::Get_Line_Data()
-{
-  digitalWrite(Load, LOW); //Let the data get into shift register IC
-  delayMicroseconds(10);
-  digitalWrite(Load, HIGH); //Loads data into the serial register for output
-  Line_Data = SPI.transfer(0x00); // Receives serially 8 bits into Line_Data variable
-  delay(10);
-  L_bits = Line_Data & 0xF0; //Get left most 4 bits
-  L_bits >>= 4;
-  R_bits = Line_Data & 0x0F;
-  
-  #ifdef DEBUG					//Debugging creates unnecessary delays which should be avoided if rover runs on timings and not on encoders!
-  Serial.println(Line_Data);
-  #endif
-  return;
-}
-
-void LineFollower::Get_Line_Data(byte& L_bits, byte& R_bits) {
-
-  this->Get_Line_Data();
-  L_bits = this->L_bits;
-  R_bits = this->R_bits;
-}
-
-
-// ****** Method graveyard below ******
-// ****** Methods below this point will need preprocessor symbol DEBUG to be defined *****
-
-// setup() and loop() functions for running as a standalone sketch
-
-#ifdef DEBUG_STANDALONE
-
-LineFollower lf;
-void setup() {lf.setup();};
-void loop() {lf.loop();};
-
-#endif
-
-/* These methods are for use when testing this as a standalone Arduino sketch
- *
- * setup(), loop()
- *
- */
- 
-#ifdef DEBUG_STANDALONE
-
-void LineFollower::setup()
-{
-  delay(2000);
-  
-  Serial.begin(9600);
-  
-  SPI.begin();
-  SPI.setClockDivider(SPI_CLOCK_DIV2);
-  SPI.setDataMode(SPI_MODE3);
-  SPI.setBitOrder(MSBFIRST);
-
-  pinMode(Load, OUTPUT);
-  digitalWrite(Load, HIGH);
-  pinMode(sensor, OUTPUT);
-  digitalWrite(sensor, HIGH); //activates LineFollower Kit
-  
-  pinMode(L_side_pin, OUTPUT);
-  pinMode(R_side_pin, OUTPUT);
-  pinMode(Dir_Right_Side, OUTPUT);
-  pinMode(Dir_Left_Side, OUTPUT);
-
-do
- {
-  Get_Line_Data();
-#ifdef DEBUG
-  Serial.println("waiting for data");
-#endif
- } while(Line_Data == 0);
-
-}
-
-void LineFollower::loop() 
-{
- //Serial.println("looping");
- Get_Line_Data();
- 
- if ( (L_bits >= 0x07) && (R_bits >= 0x07) )		  // Once rover is over the wide white line,
- {                                                    // check if it passed it once
-   if (Gate_flag == 0)                                // If not, then...
-   {
-     do                                                //Let the rover drive over the cross of white lines
-     {
-       Get_Line_Data();
-     } while( (L_bits > 0x03) && (R_bits > 0x03) );// and wait until Left and Right bits are less than %0011
-     Gate_flag = 1;                                   // Set a flag that now it did pass
-   }
-   else                                               // If rover passed once the cross of white lines,
-   {                                                  // then it should make a left turn onto it
-     Hor_Line_pass += 1;
-     if (Hor_Line_pass == 6)
-     {
-       Halt();
-     }
-     Left_Turn();
-     Demo_Run(); //Just for Demo Run
-   }
- }
-   Get_Line_Data();
-   Follow_the_line();
-//return;
-}
-
-/* NOTE: these methods are part of the demo code.
- *
- * Follow_the_line(), Move_Control(), Left_Turn(), U_Turn(), Demo_Run(), Halt()
- *
- * Motor control should be handled outside this class 
- */
-
-
-//***************Following the Line*******************************************
-void LineFollower::Follow_the_line()
-{
-  if (L_bits > R_bits)
-   {
-     L_PWM = max_speed / L_bits;
-     R_PWM = max_speed;
-   }
-  else if (R_bits > L_bits)
-   {
-     L_PWM = max_speed;
-     R_PWM = max_speed / R_bits;
-   }
-  else
-   {
-     L_PWM = max_speed;
-     R_PWM = max_speed;
-   }
-   Move_Control(L_PWM, R_PWM);
-return;
-}
-
-//***************Direction Control********************************************
-
-void LineFollower::Move_Control(short L_PWM, short R_PWM)
-{
-  //Serial.println(L_PWM);
-  //Serial.println(R_PWM);
-  digitalWrite(Dir_Left_Side, LOW);
-  digitalWrite(Dir_Right_Side,LOW);
-  analogWrite(L_side_pin, L_PWM);
-  analogWrite(R_side_pin, R_PWM);
-//  delay(10);
- return;
-}
-
-//***************Executing Left Turn*******************************************
-void LineFollower::Left_Turn()
-{
-  Num_LT = Num_LT + 1;
-//  Serial.println(Num_LT);
-  U_Turn_flag = Num_LT % 2;
-  do                                                //Let the rover drive over the cross of white lines
-  {
-    Get_Line_Data();
-  } while( (L_bits > 0x03) && (R_bits > 0x03) );// and wait until Left and Right bits are less than %0011
-  
-  for(int i=1; i<=27; i++) //Lets the rover to move a bit further after it passed the intersection before turning to the left 90 degree
-  {
-    Get_Line_Data();
-    Follow_the_line();
-  }
-  digitalWrite(Dir_Left_Side, HIGH);
-  digitalWrite(Dir_Right_Side, LOW);
-  analogWrite(L_side_pin, max_speed);
-  analogWrite(R_side_pin, max_speed);
-  delay(800);
-  do
-  {
-    Get_Line_Data();
-  } while( (L_bits >= R_bits) || (R_bits==0) );
-  
-  analogWrite(L_side_pin, 0);
-  analogWrite(R_side_pin, 0);
-  delay(25); //Let motors complete the stop
-return;
-}
-
-//*****************180 degree turn************************************************
-
-void LineFollower::U_Turn()
-{
-  
-  digitalWrite(Dir_Left_Side, HIGH);
-  digitalWrite(Dir_Right_Side, LOW);
-  analogWrite(L_side_pin, max_speed);
-  analogWrite(R_side_pin, max_speed);
-  delay(1000);
-  do
-  {
-    Get_Line_Data();
-  } while( (L_bits >= R_bits) || (R_bits==0) );
-  analogWrite(L_side_pin, 0);
-  analogWrite(R_side_pin, 0);
-  delay(25); //Let motors complete the stop
-return;
-}
-
-//*********************Demo Run********************************************************
-void LineFollower::Demo_Run()
-{
-  if (U_Turn_flag == 1) //For DEMO run through the course
-  {
-//    Serial.println("About to make a U-turn");
-    for(int i=0; i<=350; i++) //Number of iterations should be adjusted with the speed!
-    {
-      Get_Line_Data();
-      Follow_the_line();
-    }
-    U_Turn();
-  }
-return;
-}
-
-//**********************Complete Stop***************************************************
-void LineFollower::Halt()
-{
-  analogWrite(L_side_pin, 0);
-  analogWrite(R_side_pin, 0);
-  do
-  {
-  }while(1);
-}
-
-#endif
diff --git a/ROBOT_2014/TestingGround/demo/linefollow.hpp b/ROBOT_2014/TestingGround/demo/linefollow.hpp
deleted file mode 100644
index 053d388..0000000
--- a/ROBOT_2014/TestingGround/demo/linefollow.hpp
+++ /dev/null
@@ -1,101 +0,0 @@
-//Sergey Sabirov
-//Electrical Engineering Junior, Class 2015
-//
-//**************************IMPORTANT************************************
-//                     For ARDUINO MEGA 2560:
-//
-// Connect ShiftRegister IC CLOCK pin(2) to digital PIN #52 (SCK)!!!
-// Coonect ShiftRegister IC inverted OUTPUT pin(7) to digital PIN #50(MISO)
-//                     For 74HC165 IC
-// Do not forget to connect PIN15 (Clock Inhibit) to the ground!
-// Bit Reversal is implemented in hardware. See below the wiring instruction.
-
-//James Reed
-//Computer Engineering Sophomore, Class 2016
-//Modified 2/2/2014
-//
-// CHANGELOG
-// -Wrapped all of this into a class with simple methods 
-// -Tested 
-//
-//
-// Pin Assignments - Arduino Mega 2560
-// -Line Sensor enable line should be connected to Arduino pin 24
-// -Shift/!enable on shift register (pin 1) should be connected to Arduino pin 22
-// -Line Sensor pins OUT0-OUT3 correspond to pins D-A on the shift register
-// -Line Sensor pins OUT4-OUT7 correspond to pins E-H on the shift register
-//
-//
-//Preprocessor Directives:
-// -Symbol DEBUG_STANDALONE allows this to be compiled and uploaded as 
-//  a standalone Arduino sketch. The demo methods from core have been preserved.
-// -Symbols DEBUG prints the raw line data byte to the serial output
-
-
-#ifndef LINE_FOLLOW_H
-#define LINE_FOLLOW_H
-
-#include "SPI.h"
-
-//#define DEBUG_STANDALONE
-
-class LineFollower
-{
-private:
-	static const short Load    = 22; // Controls ShiftRegister's Shift/Load pin(1)
-	static const short sensor  = 24; // Controls LineFollower's Enable pin
-
-	#ifdef DEBUG_STANDALONE
-	static const short L_side_pin = 10; // PWM pin for left trek
-	static const short R_side_pin = 9;  // PWM pin for right trek
-	static const short Dir_Right_Side  =  30; // Controls direction of the right track(LOW - forward, HIGH - Reverse)
-	static const short Dir_Left_Side  =   31; // Controls direction of the left track (LOW - forward, HIGH - Reverse)
-	static const byte max_speed = 100;   // PWM value 0-255
-	#endif
-	
-	byte L_bits;
-	byte R_bits;
-	byte Line_Data;
-	
-	#ifdef DEBUG_STANDALONE
-	short L_PWM;
-	short R_PWM;
-	short Gate_flag;
-	short U_Turn_flag;
-	short Num_LT;
-	short Hor_Line_pass;
-	#endif
-	
-	void Get_Line_Data();
-	
-	/* NOTE: these methods are part of the demo code.
-	 *
-	 * Follow_the_line(), Move_Control(), Left_Turn(), U_Turn(), Demo_Run(), Halt()
-	 *
-	 * In production, Motor control should be handled outside this class 
-	 */
-	
-	#ifdef DEBUG_STANDALONE
-	void Move_Control(short L_PWM, short R_PWM);
-	void Follow_the_line();
-	void Left_Turn();
-	void U_Turn();
-	void Demo_Run();
-	void Halt();
-	#endif
-public:
-	LineFollower();
-	bool isCentered(byte& L_bits, byte& R_bits);
-	bool intersection(byte& L_bits, byte& R_bits);
-	void Get_Line_Data(byte& L_bits, byte& R_bits);
-	
-	//these methods allow this to be compiled as a standalone Arduino sketch.
-	#ifdef DEBUG_STANDALONE
-	void loop();
-	void setup();
-	#endif
-
-		
-};
-
-#endif
\ No newline at end of file
diff --git a/ROBOT_2014/TestingGround/demo/motors.cpp b/ROBOT_2014/TestingGround/demo/motors.cpp
deleted file mode 100644
index c6a35dd..0000000
--- a/ROBOT_2014/TestingGround/demo/motors.cpp
+++ /dev/null
@@ -1,148 +0,0 @@
-#include "motors.h"
-
-//Sets up the pin modes and the default speed.
-void Motors::setup(int defaultSpeed) {
-
-    delay(2);
-
-    //Set the PIN Modes
-    pinMode(PIN_PWM_LEFT, OUTPUT);
-    pinMode(PIN_DIRECTION_LEFT, OUTPUT);
-
-    pinMode(PIN_PWM_RIGHT, OUTPUT);
-    pinMode(PIN_DIRECTION_RIGHT, OUTPUT);
-
-    speed = defaultSpeed;
-
-    //Delay 2 milliseconds so we don't explode....
-    delay(2);
-}
-
-/*
- * Drives the motors in the direction passed in. The Enum Direction has FORWARD, and BACKWARD as values.
- *
- */
-void Motors::motorsDrive(Direction motorsDirection) {
-    
-    //Delay 2 milliseconds so we don't explode....
-    delay(2);
-
-    bool pinInput;
- 
-    if (motorsDirection == FORWARD) {
-        pinInput = HIGH;
-        Serial.print("pinInput is HIGH!\n");
-    }
-    else {
-        pinInput = LOW;
-        Serial.print("pinInput is LOW!\n");
-    }
-
-    digitalWrite(PIN_DIRECTION_LEFT, pinInput);
-    analogWrite(PIN_PWM_LEFT, speed);   
-
-    digitalWrite(PIN_DIRECTION_RIGHT, !pinInput);
-    analogWrite(PIN_PWM_RIGHT, speed);
-
-    //Delay 2 milliseconds so we don't explode....
-    delay(2);
-}
-
-//Adjust the speed of each motor manually by passing a PWM 
-void Motors::motorsTurn(short leftPWM, short rightPWM, Turn motorsTurn) {
-
-    delay(2);
-
-    bool pinInput;
-
-    if (motorsTurn == RIGHT) {
-        pinInput = LOW;
-    }
-    else if (motorsTurn == LEFT) {
-        pinInput = HIGH;
-    }
-    else {
-        Serial.println("WTF....");
-        pinInput1 = HIGH;
-        pinInput2 = LOW;
-    }
-
-    digitalWrite(PIN_DIRECTION_LEFT, pinInput1);
-    digitalWrite(PIN_DIRECTION_RIGHT, pinInput2);
-    analogWrite(PIN_PWM_LEFT, leftPWM);
-    analogWrite(PIN_PWM_RIGHT, rightPWM);
-
-    delay(2);
-}
-
-//
-void Motors::motorsUTurn() {
-
-    delay(2);
-
-    this->motorsTurn(RIGHT);
-    delay(3000);
-    this->motorsStop();
-
-    delay(2);
-}
-
-//Turns the robot left.
-void Motors::motorsTurnLeft() {
-    
-    //Delay 2 milliseconds so we don't explode....
-    delay(2);
-
-    this->motorsTurn(LEFT);
-
-    //Delay 2 milliseconds so we don't explode....
-    delay(2);
-}
-
-//Turns the robot right.
-void Motors::motorsTurnRight() {
-    
-    //Delay 2 milliseconds so we don't explode....
-    delay(2);
-
-    this->motorsTurn(RIGHT);
-
-    //Delay 2 milliseconds so we don't explode....
-    delay(2);
-}
-
-//Turns the motors in the specified direction (used to make the above methods work, not to be interfaced with)
-void Motors::motorsTurn(Turn motorsTurn){
-
-    //Delay 2 milliseconds so we don't explode....
-    delay(2);
-
-    bool pinInput;
-
-    if (motorsTurn == RIGHT) 
-        pinInput = LOW;
-    else
-        pinInput = HIGH;
-
-    digitalWrite(PIN_DIRECTION_LEFT, pinInput);
-    analogWrite(PIN_PWM_LEFT, speed);   
-
-    digitalWrite(PIN_DIRECTION_RIGHT, pinInput);
-    analogWrite(PIN_PWM_RIGHT, speed);   
-
-    //Delay 2 milliseconds so we don't explode....
-    delay(2);
-}
-
-//Cuts power to the motors, roll to a stop
-void Motors::motorsStop() {
-
-    //Delay 2 milliseconds so we don't explode....
-    delay(2);
-
-    analogWrite(PIN_PWM_LEFT, 0);  
-    analogWrite(PIN_PWM_RIGHT, 0);  
-
-    //Delay 2 milliseconds so we don't explode....
-    delay(2);
-}
\ No newline at end of file
diff --git a/ROBOT_2014/TestingGround/demo/motors.h b/ROBOT_2014/TestingGround/demo/motors.h
deleted file mode 100644
index a729e4b..0000000
--- a/ROBOT_2014/TestingGround/demo/motors.h
+++ /dev/null
@@ -1,50 +0,0 @@
-#ifndef MOTORS_H
-#define MOTORS_H
-
-#include <Arduino.h>
-
-//Define the Pins----------
-//Motor Pair 1 (ON THE LEFT SIDE)
-#define PIN_DIRECTION_LEFT 26 //Direction
-#define PIN_PWM_LEFT 3 //Speed
-
-//Motor Pair 2 (ON THE RIGHT SIDE)
-#define PIN_DIRECTION_RIGHT 28 //Direction
-#define PIN_PWM_RIGHT 4 //Speed
-
-//Enum for specifying direction to move in
-enum Direction { FORWARD = 1, BACKWARD };
-
-//Enum for specifying the direction to turn in
-enum Turn {	LEFT = 1, RIGHT };
-
-//~Class for moving all of the motors at once
-class Motors
-{
-	//==================================================
-	//~~PIN INFORMATION=================================
-	//==================================================
-	/*
-		Connections:
-		- Pin 3 ---> PWM for left motors
-		- Pin 8 ---> PIN_DIRECTION_LEFT
-
-		- Pin 4 ---> PWM for right motors
-		- Pin 9 ---> PIN_DIRECTION_RIGHT
-	*/
-	//==================================================
-
-	public:
-		void setup(int defaultSpeed);
-		void motorsDrive(Direction motorsDirection);
-		void motorsStop();
-		void motorsTurnLeft();
-		void motorsTurnRight();
-		void motorsTurn(Turn motorsTurn);
-		void motorsTurn(short leftPWM, short rightPWM);
-		void motorsUTurn();
-		int speed;
-	private:
-		void motorsTurn(short leftPWM, short rightPWM, Turn motorsTurn);
-};
-#endif
\ No newline at end of file
diff --git a/ROBOT_2014/TestingGround/demo/pins.h b/ROBOT_2014/TestingGround/demo/pins.h
deleted file mode 100644
index 7ad6e4b..0000000
--- a/ROBOT_2014/TestingGround/demo/pins.h
+++ /dev/null
@@ -1,17 +0,0 @@
-#ifndef PIN_DEFINITIONS_H_
-#define PIN_DEFINITIONS_H_
-
-//Pin assignments--------------------------
-
-//Motor Pair 1 (ON THE LEFT SIDE)
-#define PIN_DIRECTION_LEFT 8 //Direction
-#define PIN_PWM_LEFT 3 //Speed
-//Motor Pair 2 (ON THE RIGHT SIDE)
-#define PIN_DIRECTION_RIGHT 9 //Direction
-#define PIN_PWM_RIGHT 4 //Speed
-
-//Line Sensor Pins
-#define Load 22 // Controls ShiftRegister's Shift/Load pin(1)
-#define sensor 24 // Controls LineFollower's Enable pin
-
-#endif
